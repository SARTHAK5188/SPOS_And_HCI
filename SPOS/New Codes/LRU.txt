Line-by-line explanation (every important line, plain language)
get_input()

ref = input(...).strip() — read user line, remove whitespace.

If not ref, error and return (None, None).

pages = list(map(int, ref.split())) — split on whitespace, convert tokens to ints; ValueError caught and returns (None, None) if any token non-numeric.

frames_count = int(input(...).strip()) — read number of frames; require > 0.

Return (pages, frames_count).

run_lru(pages, frames_count)

frames = []: list of currently loaded pages (keeps positions).

last_used = {}: dictionary mapping each page currently tracked to the last time index t it was referenced.

page_faults = 0: counter.

Main loop:

for t, page in enumerate(pages):


enumerate gives t=0.. and page value.

Hit case:

if page in frames:
    last_used[page] = t
    print(... (hit))
    continue


If page already loaded, update its last used time to current t (recency) and report a hit.

Miss/fault:

page_faults += 1
if len(frames) < frames_count:
    frames.append(page)
    last_used[page] = t
    print(... (fault, loaded))
    continue


If there's empty frame, load the page into an empty slot, update last_used.

Replacement:

lru_page = min(frames, key=lambda p: last_used.get(p, -1))
replace_index = frames.index(lru_page)
frames[replace_index] = page
del last_used[lru_page]
last_used[page] = t
print(... replaced lru_page)


min(frames, key=...) picks the page with smallest last_used value — that is Least Recently Used.

frames.index(lru_page) finds its position so we can replace it.

Replace it in frames, remove its last_used entry, and add the new page with last_used = t.

After loop print total faults and return page_faults.

What LRU does conceptually (short)

At each page reference, if page present → hit; update its recency.

If not present → page fault. If free frame → load. Else → evict the page that was referenced least recently (i.e., whose last use time is smallest), and load the new page there.

LRU approximates "keep recently used pages" and tends to avoid evicting frequently used pages. It does not suffer Belady’s anomaly like FIFO sometimes does.

Full worked example — every arithmetic operation shown digit-by-digit

Use the common textbook reference string:

pages = [7, 0, 1, 2, 0, 3, 0, 4, 2]
frames_count = 3


We’ll step through each reference and show frames, last_used, page_faults after each step, performing any arithmetic explicitly.

Initial:

frames = []

last_used = {}

page_faults = 0

t = 0, page = 7

Check if 7 in frames? frames is empty → False.

page_faults += 1 → previous 0 + 1 = 1. (Digit-by-digit: 0 + 1 = 1.)

len(frames) < frames_count → 0 < 3 → True ⇒ load page:

frames.append(7) → frames becomes [7].

last_used[7] = 0

Print: Ref 7 -> Frames: [7] (fault, loaded)

t = 1, page = 0

0 in frames? [7] → False.

page_faults = 1 + 1 = 2.

len(frames) < 3 → 1 < 3 True ⇒ load:

frames = [7, 0]

last_used[0] = 1

Print: Ref 0 -> Frames: [7, 0] (fault, loaded)

t = 2, page = 1

1 in frames? [7,0] → False.

page_faults = 2 + 1 = 3.

len(frames) < 3 → 2 < 3 True ⇒ load:

frames = [7, 0, 1]

last_used[1] = 2

Print: Ref 1 -> Frames: [7, 0, 1] (fault, loaded)

t = 3, page = 2

2 in frames? [7,0,1] → False.

page_faults = 3 + 1 = 4.

len(frames) < 3 → 3 < 3 False → need replacement.

Compute LRU: look at last_used for pages in frames:

last_used[7] = 0

last_used[0] = 1

last_used[1] = 2

Smallest is 0 (page 7). So lru_page = 7.

replace_index = frames.index(7) → 0. (7 is at position 0)

frames[0] = 2 ⇒ frames becomes [2, 0, 1].

del last_used[7] removes entry for 7.

last_used[2] = 3

Print: Ref 2 -> Frames: [2, 0, 1] (fault, replaced 7)

t = 4, page = 0

0 in frames? [2,0,1] → True.

Hit: update last_used[0] = 4.

page_faults remains 4.

Print: Ref 0 -> Frames: [2, 0, 1] (hit)

t = 5, page = 3

3 in frames? False.

page_faults = 4 + 1 = 5.

Frames full → find LRU among frames [2,0,1] with last_used:

last_used[2] = 3

last_used[0] = 4

last_used[1] = 2

Smallest is 2 → page 1 is LRU.

replace_index = frames.index(1) → 2.

frames[2] = 3 ⇒ frames becomes [2, 0, 3].

del last_used[1].

last_used[3] = 5.

Print: Ref 3 -> Frames: [2, 0, 3] (fault, replaced 1)

t = 6, page = 0

0 in frames? True.

Update last_used[0] = 6.

page_faults stays 5.

Print: Ref 0 -> Frames: [2, 0, 3] (hit)

t = 7, page = 4

4 in frames? False.

page_faults = 5 + 1 = 6.

LRU among [2,0,3] with last_used:

last_used[2] = 3

last_used[0] = 6

last_used[3] = 5

Smallest is 3 → page 2 is LRU.

replace_index = frames.index(2) → 0.

frames[0] = 4 ⇒ frames [4,0,3].

del last_used[2].

last_used[4] = 7.

Print: Ref 4 -> Frames: [4, 0, 3] (fault, replaced 2)

t = 8, page = 2

2 in frames? False.

page_faults = 6 + 1 = 7.

LRU among [4,0,3] with last_used:

last_used[4] = 7

last_used[0] = 6

last_used[3] = 5

Smallest is 5 → page 3 is LRU.

replace_index = frames.index(3) → 2.

frames[2] = 2 ⇒ frames [4,0,2].

del last_used[3].

last_used[2] = 8.

Print: Ref 2 -> Frames: [4, 0, 2] (fault, replaced 3)

End:

page_faults = 7. (Final printed line: Total page faults (LRU): 7)

So the LRU algorithm produced 7 page faults for the example sequence and 3 frames.

Observations from the example (explicit)

LRU keeps recently used pages; when a page is referenced it moves forward in recency (we track that by last_used[page] = t).

At t=4 and t=6 several hits occurred because 0 was used recently.

Replacement choices are determined by the smallest last_used among pages currently residing in frames.